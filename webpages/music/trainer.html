<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web å…¨èƒ½éŸ³ä¹å¬åŠ›è®­ç»ƒå™¨ (Pro V2)</title>
    <style>
        :root {
            /* æš—è‰²å¤å¤é…è‰² */
            --primary: #f4d35e;    /* ç¥ç€é»„ */
            --secondary: #1f7a8c;  /* å¤å¤è“ç»¿ */
            --accent: #e3645b;     /* å¤å¤çº¢ */
            --bg: #0f1624;         /* æ·±å¤œè“ */
            --card: #1b2433;       /* æ·±å¡ç‰‡ */
            --text: #e6e1d9;       /* æš–ç™½æ–‡å­— */
            --muted: #cfd0d4;      /* æ¬¡çº§æ–‡å­—ï¼Œæäº® */
            --panel: #151d2b;      /* é¢æ¿èƒŒæ™¯ */
            --highlight: #9ef01a;  /* ç‚¹ç¼€ç»¿ */
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: radial-gradient(120% 120% at 50% 30%, #18243a 0%, #0b111e 55%, #060a12 100%);
            color: var(--text);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            min-height: 100vh;
        }

        .container {
            background: var(--card);
            width: 100%;
            max-width: 1000px;
            border-radius: 14px;
            box-shadow: 0 18px 35px rgba(0,0,0,0.35);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            border: 1px solid rgba(255,255,255,0.06);
        }

        /* Tabs */
        .tabs {
            display: flex;
            background: var(--panel);
            overflow-x: auto;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        /* Top controls */
        .top-controls {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 20px;
            background: var(--panel);
            border-bottom: 1px solid rgba(255,255,255,0.06);
        }
        .top-controls .divider {
            width: 1px;
            height: 18px;
            background: rgba(255,255,255,0.12);
        }
        .top-controls select {
            border: 1px solid rgba(255,255,255,0.2);
            background: rgba(255,255,255,0.05);
            color: var(--text);
            border-radius: 6px;
            padding: 6px 10px;
            font-size: 0.9rem;
        }
        
        /* Draggable Sortable List */
        .sortable-list {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            padding: 5px;
            min-height: 40px;
            border: 1px dashed rgba(255,255,255,0.12);
            border-radius: 8px;
            background: rgba(255,255,255,0.03);
            align-items: center;
        }
        .sortable-item {
            display: flex;
            align-items: center;
            background: rgba(255,255,255,0.05);
            padding: 5px 10px;
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: 6px;
            cursor: grab;
            user-select: none;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .sortable-item.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }
        .sortable-item:hover {
            box-shadow: 0 4px 10px rgba(0,0,0,0.35);
        }
        .sortable-handle {
            margin-right: 8px;
            color: #c9c4b8;
            cursor: grab;
        }

        /* Key cards (keyboard tab) */
        .key-card {
            background: rgba(255,255,255,0.05) !important;
            border: 1px solid rgba(255,255,255,0.12) !important;
            border-radius: 8px !important;
            padding: 12px 10px !important;
            text-align: center;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        .key-card:hover {
            background: rgba(255,255,255,0.08) !important;
            box-shadow: 0 6px 14px rgba(0,0,0,0.35);
        }

        .tab-btn {
            flex: 1;
            padding: 15px;
            border: none;
            background: transparent;
            font-weight: 600;
            color: #c7cedd;
            cursor: pointer;
            white-space: nowrap;
            transition: all 0.2s;
            border-bottom: 3px solid transparent;
        }
        .tab-btn.active {
            background: #111827;
            color: var(--primary);
            border-bottom-color: var(--primary);
        }
        .tab-btn:hover:not(.active) {
            background: rgba(255,255,255,0.05);
        }

        /* Content */
        .content {
            padding: 20px;
            display: none;
        }
        .content.active {
            display: block;
        }

        /* Sections */
        .section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255,255,255,0.06);
        }
        .section-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* Controls */
        .grid-options {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 8px;
        }
        .flex-row {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        label {
            display: flex;
            align-items: center;
            font-size: 0.9rem;
            cursor: pointer;
            user-select: none;
        }
        input[type="checkbox"], input[type="radio"] {
            accent-color: var(--primary);
            margin-right: 6px;
        }
        select, input[type="number"] {
            padding: 6px;
            border: 1px solid rgba(255,255,255,0.25);
            background: rgba(255,255,255,0.08);
            color: var(--text);
            border-radius: 6px;
        }
        select option, select optgroup {
            background: #0f1624;
            color: var(--text);
        }

        /* Special Toggle for Sequence Mode */
        .seq-toggle {
            background-color: rgba(158, 240, 26, 0.08);
            border: 1px solid rgba(158, 240, 26, 0.35);
            padding: 5px 10px;
            border-radius: 6px;
            color: #c7f77b;
            font-weight: bold;
        }

        /* Status Box */
        .status-box {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            margin-top: 10px;
            min-height: 80px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        .main-text { font-size: 1.5rem; font-weight: bold; color: var(--primary); margin: 5px 0; }
        .sub-text { font-size: 0.9rem; color: var(--muted); }
        .seq-tag { font-size: 0.8rem; background: var(--accent); color: white; padding: 2px 6px; border-radius: 4px; margin-left: 8px; vertical-align: middle; }

        /* Buttons */
        .action-bar {
            padding: 20px;
            background: var(--panel);
            border-top: 1px solid rgba(255,255,255,0.08);
            display: flex;
            gap: 15px;
        }
        .btn {
            flex: 1;
            padding: 12px;
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 8px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: 0.2s;
            background: rgba(255,255,255,0.04);
            color: var(--text);
        }
        .btn-start { background: var(--primary); color: #0c0c0c; }
        .btn-start:hover { background: #ffd36a; }
        .btn-stop { background: var(--accent); color: #0c0c0c; }
        .btn-stop:disabled { background: rgba(255,255,255,0.1); color: rgba(255,255,255,0.4); cursor: not-allowed; }

        /* Helpers */
        .note-selector {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }
        .note-check {
            border: 1px solid #ccc;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.85rem;
            cursor: pointer;
        }
        .note-check.checked {
            background: var(--secondary);
            color: white;
            border-color: var(--secondary);
        }
    </style>
</head>
<body>

<div class="container">
    <!-- é¡¶éƒ¨å¯¼èˆª -->
    <div class="tabs">
        <button class="tab-btn active" onclick="switchTab('interval-loop')">â‘  éŸ³ç¨‹å¾ªç¯</button>
        <button class="tab-btn" onclick="switchTab('chord-loop')">â‘¡ å’Œå¼¦å¾ªç¯</button>
        <button class="tab-btn" onclick="switchTab('interval-quiz')">â‘¢ éŸ³ç¨‹å¬è¾¨(è¯­éŸ³)</button>
        <button class="tab-btn" onclick="switchTab('chord-quiz')">â‘£ å’Œå¼¦å¬è¾¨(è¯­éŸ³)</button>
        <button class="tab-btn" onclick="switchTab('note-quiz')">â‘¤ å•éŸ³å¬è¾¨(è¯­éŸ³)</button>
        <button class="tab-btn" onclick="switchTab('keyboard-mode')">â‘¥ é”®ç›˜æ§åˆ¶(Pro)</button>
    </div>

    <!-- éŸ³é‡ / éŸ³è‰² æ§åˆ¶æ¡ -->
    <div class="top-controls">
        <span style="font-size: 0.9rem; font-weight: 600; color: var(--text);">ğŸ”Š éŸ³é‡</span>
        <input type="range" id="vol-slider" min="0" max="1" step="0.01" value="0.5" style="width: 140px; height: 4px; accent-color: var(--primary);">
        <span id="vol-display" style="font-size: 0.9rem; min-width: 46px; text-align: right;">50%</span>
        
        <div class="divider"></div>
        
        <span style="font-size: 0.9rem; font-weight: 600; color: var(--text);">ğŸ¨ éŸ³è‰²</span>
        <select id="timbre-select">
            <option value="osc">ğŸŒŠ åˆæˆå™¨</option>
            <option value="piano">ğŸ¹ é’¢ç´</option>
            <option value="guitar-acoustic">ğŸ¸ åŸå£°å‰ä»–</option>
            <option value="guitar-electric">ğŸ¸ ç”µå‰ä»–</option>
            <option value="violin">ğŸ» å°æç´</option>
        </select>
    </div>

    <!-- é€šç”¨è®¾ç½®åŒºåŸŸ -->
    <div style="padding: 20px 20px 0 20px; border-bottom: 1px dashed #ccc;">
        <div class="section-title">é€šç”¨è®¾ç½®ï¼šæ ¹éŸ³è¿‡æ»¤ & èŒƒå›´</div>
        <div class="flex-row" style="margin-bottom: 10px;">
            <span>éŸ³åŸŸèŒƒå›´:</span>
            <select id="range-min" style="width:80px"></select> 
            <span>è‡³</span> 
            <select id="range-max" style="width:80px"></select>
        </div>
        <div class="flex-row">
            <span style="font-size:0.9rem;">å…è®¸çš„æ ¹éŸ³å:</span>
            <div class="note-selector" id="root-note-filter">
                <!-- JS ç”Ÿæˆ C, C#, D ... -->
            </div>
            <button onclick="toggleAllNotes()" style="font-size:0.8rem; padding:2px 8px;">å…¨é€‰/åé€‰</button>
        </div>
    </div>

    <!-- Tab 1: éŸ³ç¨‹å¾ªç¯ -->
    <div id="interval-loop" class="content active">
        <div class="section">
            <div class="section-title">é€‰æ‹©éŸ³ç¨‹ (å¤šé€‰) <button onclick="setChecks('int-list-loop', true)">å…¨é€‰</button><button onclick="toggleChecks('int-list-loop')">åé€‰</button></div>
            <div class="grid-options" id="int-list-loop"></div>
        </div>
        <div class="section">
            <div class="section-title">æ’­æ”¾è®¾ç½® (æ‹–æ‹½è°ƒæ•´é¡ºåº)</div>
            <div class="sortable-list" id="sort-dir-loop">
                <div class="sortable-item" draggable="true" data-val="asc">
                    <span class="sortable-handle">â˜°</span>
                    <label style="margin:0; cursor:inherit;"><input type="checkbox" class="play-dir-loop" value="asc" checked> ä¸Šè¡Œ</label>
                </div>
                <div class="sortable-item" draggable="true" data-val="desc">
                    <span class="sortable-handle">â˜°</span>
                    <label style="margin:0; cursor:inherit;"><input type="checkbox" class="play-dir-loop" value="desc" checked> ä¸‹è¡Œ</label>
                </div>
                <div class="sortable-item" draggable="true" data-val="harm">
                    <span class="sortable-handle">â˜°</span>
                    <label style="margin:0; cursor:inherit;"><input type="checkbox" class="play-dir-loop" value="harm" checked> å’Œå£°</label>
                </div>
            </div>
            
            <!-- æ–°å¢ï¼šé¡ºåºæ¨¡å¼å¼€å…³ -->
            <div style="margin-top:15px;">
                <label class="seq-toggle">
                    <input type="checkbox" id="seq-mode-int" checked> é”å®šéŸ³ç»„ï¼šä¾æ¬¡æ’­æ”¾æ‰€æœ‰é€‰ä¸­æ¨¡å¼ (é¡ºåºæ’­æ”¾)
                </label>
            </div>

            <div class="flex-row" style="margin-top:15px;">
                <span>é€Ÿåº¦(ms):</span> <input type="number" id="speed-loop" value="400" step="50" style="width:60px">
                <span>é—´éš”(s):</span> <input type="number" id="gap-loop" value="0.5" step="0.5" style="width:60px">
                <span>é‡å¤æ¬¡æ•°:</span> <input type="number" id="repeat-loop-int" value="1" min="1" style="width:50px">
            </div>
        </div>
    </div>

    <!-- Tab 2: å’Œå¼¦å¾ªç¯ -->
    <div id="chord-loop" class="content">
        <div class="section">
            <div class="section-title">é€‰æ‹©å’Œå¼¦ (å¤šé€‰) <button onclick="setChecks('chord-list-loop', true)">å…¨é€‰</button><button onclick="toggleChecks('chord-list-loop')">åé€‰</button></div>
            <div class="grid-options" id="chord-list-loop"></div>
        </div>
        
        <!-- æ–°å¢ï¼šè‡ªå®šä¹‰å’Œå¼¦æ·»åŠ åŒºåŸŸ -->
        <div class="section" style="background: rgba(255,255,255,0.03); border: 1px dashed rgba(255,255,255,0.15); padding: 10px; border-radius: 8px;">
            <div class="section-title" style="font-size: 1rem;">æ·»åŠ è‡ªå®šä¹‰å’Œå¼¦</div>
             <div class="flex-row" style="align-items: flex-end;">
                <div>
                    <div style="font-size:0.8rem;color:#999;margin-bottom:4px;">åç§° (å¦‚: MyMaj9)</div>
                    <input type="text" id="new-chord-name" style="width:110px">
                </div>
                <div>
                    <div style="font-size:0.8rem;color:#999;margin-bottom:4px;">éŸ³ç¨‹ (åŠéŸ³, é€—å·åˆ†éš”)</div>
                    <input type="text" id="new-chord-int" placeholder="0,4,7,11" style="width:140px">
                </div>
                <button onclick="addCustomChord()" style="padding:6px 15px; background:var(--highlight); color:black; border:none; border-radius:4px; cursor:pointer;">æ·»åŠ </button>
            </div>
            <div style="margin-top:5px; font-size:0.8rem; color:#999;">æ³¨ï¼š0ä»£è¡¨æ ¹éŸ³ã€‚ä¾‹å¦‚å¤§ä¸‰å’Œå¼¦ä¸º 0,4,7</div>
        </div>

        <div class="section">
            <div class="section-title">æ’­æ”¾è®¾ç½® (æ‹–æ‹½è°ƒæ•´é¡ºåº)</div>
            <div class="sortable-list" id="sort-dir-chord">
                <div class="sortable-item" draggable="true" data-val="up">
                    <span class="sortable-handle">â˜°</span>
                    <label style="margin:0; cursor:inherit;"><input type="checkbox" class="chord-dir-loop" value="up" checked> ä¸Šè¡Œç¶éŸ³</label>
                </div>
                <div class="sortable-item" draggable="true" data-val="down">
                    <span class="sortable-handle">â˜°</span>
                    <label style="margin:0; cursor:inherit;"><input type="checkbox" class="chord-dir-loop" value="down" checked> ä¸‹è¡Œç¶éŸ³</label>
                </div>
                <div class="sortable-item" draggable="true" data-val="harmonic">
                    <span class="sortable-handle">â˜°</span>
                    <label style="margin:0; cursor:inherit;"><input type="checkbox" class="chord-dir-loop" value="harmonic" checked> æŸ±å¼å’Œå¼¦</label>
                </div>
            </div>

            <!-- æ–°å¢ï¼šé¡ºåºæ¨¡å¼å¼€å…³ -->
            <div style="margin-top:15px;">
                <label class="seq-toggle">
                    <input type="checkbox" id="seq-mode-chord" checked> é”å®šéŸ³ç»„ï¼šä¾æ¬¡æ’­æ”¾æ‰€æœ‰é€‰ä¸­æ¨¡å¼ (é¡ºåºæ’­æ”¾)
                </label>
            </div>

            <div class="flex-row" style="margin-top:15px;">
                <span>ç¶éŸ³é€Ÿåº¦:</span> <input type="number" id="arp-speed-loop" value="150" style="width:60px">
                <span>æŸ±å¼æ—¶é•¿:</span> <input type="number" id="chord-dur-loop" value="1200" step="100" style="width:60px">
                <span>é—´éš”(s):</span> <input type="number" id="chord-gap-loop" value="0.5" step="0.5" style="width:60px">
                <span>é‡å¤æ¬¡æ•°:</span> <input type="number" id="repeat-loop-chord" value="1" min="1" style="width:50px">
            </div>
            
            <div class="section-title" style="margin-top:20px;">é«˜çº§ Voicing è®¾ç½®</div>
            <div class="flex-row">
                <label><input type="checkbox" id="inv-loop" checked> å…è®¸è½¬ä½</label>
                <label><input type="checkbox" id="double-loop"> å…è®¸å…«åº¦é‡å¤</label>
                <span>éŸ³æ•°ä¸Šé™: <input type="number" id="max-notes-loop" value="4" min="3" max="8" style="width:50px"></span>
            </div>
        </div>
    </div>

    <!-- Tab 3: éŸ³ç¨‹å¬è¾¨ (è¯­éŸ³) -->
    <div id="interval-quiz" class="content">
        <div class="section">
            <div class="section-title">å¬è¾¨èŒƒå›´ (24ä¸ªéŸ³ç¨‹) <button onclick="setChecks('int-list-quiz', true)">å…¨é€‰</button><button onclick="toggleChecks('int-list-quiz')">åé€‰</button></div>
            <div class="grid-options" id="int-list-quiz" style="grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));"></div>
        </div>
        <div class="section">
            <div class="section-title">æ’­æŠ¥è®¾ç½®</div>
            <div class="flex-row">
                 <label><input type="checkbox" id="speak-root-int"> æ’­æŠ¥æ ¹éŸ³ (å¦‚: "C å¤§ä¸‰åº¦")</label>
                 <span>æ’­æ”¾æ¨¡å¼:</span>
                 <select id="quiz-int-mode">
                     <option value="asc">ä»…ä¸Šè¡Œ</option>
                     <option value="desc">ä»…ä¸‹è¡Œ</option>
                     <option value="harm">ä»…å’Œå£°</option>
                     <option value="random" selected>éšæœºæ··åˆ</option>
                 </select>
            </div>
            <div class="flex-row" style="margin-top:10px;">
                <span>é—´éš”(s):</span> <input type="number" id="gap-quiz-int" value="0.5" step="0.5" style="width:60px">
                <span>æ’­æ”¾æ¬¡æ•°:</span> <input type="number" id="repeat-quiz-int" value="1" min="1" style="width:50px">
                <small style="color:#999; margin-left:10px;">(å£°éŸ³æ’­æŠ¥å®Œåçš„ç­‰å¾…æ—¶é—´)</small>
            </div>
        </div>
    </div>

    <!-- Tab 4: å’Œå¼¦å¬è¾¨ (è¯­éŸ³) -->
    <div id="chord-quiz" class="content">
        <div class="section">
            <div class="section-title">å¬è¾¨èŒƒå›´ <button onclick="setChecks('chord-list-quiz', true)">å…¨é€‰</button><button onclick="toggleChecks('chord-list-quiz')">åé€‰</button></div>
            <div class="grid-options" id="chord-list-quiz"></div>
        </div>
        <div class="section">
            <div class="section-title">æ’­æŠ¥ä¸éš¾åº¦</div>
            <div class="flex-row">
                 <label><input type="checkbox" id="speak-root-chord"> æ’­æŠ¥æ ¹éŸ³ (å¦‚: "D å°ä¸ƒ")</label>
                 <label><input type="checkbox" id="inv-quiz"> åŒ…å«è½¬ä½</label>
            </div>
            <div class="flex-row" style="margin-top:10px;">
                <span>é—´éš”(s):</span> <input type="number" id="gap-quiz-chord" value="0.5" step="0.5" style="width:60px">
                <span>æ’­æ”¾æ¬¡æ•°:</span> <input type="number" id="repeat-quiz-chord" value="1" min="1" style="width:50px">
            </div>
        </div>
    </div>

    <!-- Tab 5: å•éŸ³å¬è¾¨ (è¯­éŸ³) -->
    <div id="note-quiz" class="content">
        <div class="section">
            <div class="section-title">è¯´æ˜</div>
            <p style="margin:0; color:#999; font-size:0.9rem;">
                æ­¤æ¨¡å¼å°†éšæœºæ’­æ”¾â€œé€šç”¨è®¾ç½®â€ä¸­é€‰ä¸­çš„éŸ³ç¬¦ï¼ˆå¦‚C, D, Eç­‰ï¼‰ï¼Œå¹¶åœ¨æ’­æ”¾åè¯­éŸ³æŠ¥å‡ºéŸ³åã€‚
                <br>é€‚åˆç»å¯¹éŸ³æ„Ÿè®­ç»ƒã€‚å»ºè®®åœ¨ä¸Šæ–¹å‡å°‘é€‰ä¸­çš„æ ¹éŸ³æ•°é‡ï¼Œä»3-4ä¸ªéŸ³å¼€å§‹ç»ƒä¹ ã€‚
            </p>
        </div>
        <div class="section">
            <div class="section-title">è®¾ç½®</div>
            <div class="flex-row">
                <span>éŸ³é•¿(ms):</span> <input type="number" id="note-dur-quiz" value="800" style="width:60px">
                <span>é—´éš”(s):</span> <input type="number" id="gap-quiz-note" value="0.5" step="0.5" style="width:60px">
                <span>æ’­æ”¾æ¬¡æ•°:</span> <input type="number" id="repeat-quiz-note" value="1" min="1" style="width:50px">
            </div>
        </div>
    </div>

    <!-- Tab 6: é”®ç›˜æ§åˆ¶æ¨¡å¼ -->
    <div id="keyboard-mode" class="content">
        <div class="section">
            <div class="section-title">
                <span>å¿«æ·é”®æ˜ å°„ (æŒ‰é”®ç›´æ¥æ’­æ”¾)</span>
                <label style="font-size:0.9rem; display:flex; align-items:center;">
                    <input type="checkbox" id="key-loop-mode"> å¾ªç¯æ’­æ”¾å½“å‰éŸ³ç¨‹
                </label>
            </div>
            <!-- ç”Ÿæˆ 12 ä¸ªæŒ‰é”®å¡ç‰‡ -->
            <div class="grid-options" id="key-map-display" style="grid-template-columns: repeat(4, 1fr); gap:10px;">
                <!-- JS å¡«å…… -->
            </div>
        </div>

        <div class="section">
            <div class="section-title">æ’­æ”¾è®¾ç½® (æ‹–æ‹½è°ƒæ•´é¡ºåº)</div>
            <div class="sortable-list" id="sort-dir-key">
                <div class="sortable-item" draggable="true" data-val="asc">
                    <span class="sortable-handle">â˜°</span>
                    <label style="margin:0; cursor:inherit;"><input type="checkbox" class="play-dir-key" value="asc" checked> ä¸Šè¡Œ</label>
                </div>
                <div class="sortable-item" draggable="true" data-val="desc">
                    <span class="sortable-handle">â˜°</span>
                    <label style="margin:0; cursor:inherit;"><input type="checkbox" class="play-dir-key" value="desc" checked> ä¸‹è¡Œ</label>
                </div>
                <div class="sortable-item" draggable="true" data-val="harm">
                    <span class="sortable-handle">â˜°</span>
                    <label style="margin:0; cursor:inherit;"><input type="checkbox" class="play-dir-key" value="harm" checked> å’Œå£°</label>
                </div>
            </div>

            <div class="flex-row" style="margin-top:15px;">
                <span>é€Ÿåº¦(ms):</span> <input type="number" id="speed-key" value="400" step="50" style="width:60px">
                <span>é—´éš”(s):</span> <input type="number" id="gap-key" value="0.5" step="0.5" style="width:60px">
            </div>
        </div>
        
        <div class="status-box" style="margin:0; background:#f0f8ff; border:1px dashed #bddaf9; color:#4a69bd;">
            æç¤ºï¼šè¯·ç¡®ä¿è¾“å…¥æ³•å·²åˆ‡æ¢ä¸ºè‹±æ–‡æ¨¡å¼ï¼Œå¦åˆ™æŒ‰é”®å¯èƒ½æ— æ•ˆã€‚
        </div>
    </div>

    <!-- åº•éƒ¨çŠ¶æ€ä¸æ“ä½œ -->
    <div class="status-box" id="status-display">
        <div class="main-text">å‡†å¤‡å°±ç»ª</div>
        <div class="sub-text">è¯·é€‰æ‹©æ¨¡å¼å¹¶ç‚¹å‡»å¼€å§‹</div>
    </div>

    <div class="action-bar">
        <button class="btn btn-start" id="btn-toggle">å¼€å§‹è®­ç»ƒ (Space)</button>
    </div>
</div>

<script>
    // --- å…¨å±€æ•°æ® ---
    const NOTE_NAMES = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    
    // 0-24ä¸ªåŠéŸ³çš„éŸ³ç¨‹å®šä¹‰
    const INTERVALS = [
        { semitones: 1, name: "å°äºŒåº¦ (m2)" }, { semitones: 2, name: "å¤§äºŒåº¦ (M2)" },
        { semitones: 3, name: "å°ä¸‰åº¦ (m3)" }, { semitones: 4, name: "å¤§ä¸‰åº¦ (M3)" },
        { semitones: 5, name: "çº¯å››åº¦ (P4)" }, { semitones: 6, name: "ä¸‰å…¨éŸ³ (TT)" },
        { semitones: 7, name: "çº¯äº”åº¦ (P5)" }, { semitones: 8, name: "å°å…­åº¦ (m6)" },
        { semitones: 9, name: "å¤§å…­åº¦ (M6)" }, { semitones: 10, name: "å°ä¸ƒåº¦ (m7)" },
        { semitones: 11, name: "å¤§ä¸ƒåº¦ (M7)" }, { semitones: 12, name: "çº¯å…«åº¦ (P8)" },
        { semitones: 13, name: "å°ä¹åº¦ (m9)" }, { semitones: 14, name: "å¤§ä¹åº¦ (M9)" },
        { semitones: 15, name: "å°ååº¦ (m10)" }, { semitones: 16, name: "å¤§ååº¦ (M10)" },
        { semitones: 17, name: "çº¯åä¸€ (P11)" }, { semitones: 19, name: "çº¯åäºŒ (P12)" },
        { semitones: 24, name: "åäº”åº¦ (P15)" }
    ];

const DEFAULT_CHORDS = [
  { id: 'maj',      name: 'å¤§ä¸‰',                 int: [0, 4, 7] },
  { id: 'min',      name: 'å°ä¸‰',                 int: [0, 3, 7] },
  { id: 'aug',      name: 'å¢ä¸‰',             int: [0, 4, 8] },
  { id: 'dim',      name: 'å‡ä¸‰',            int: [0, 3, 6] },
  { id: 'sus4',     name: 'æŒ‚å››',         int: [0, 5, 7] },
  { id: 'maj7',     name: 'å¤§ä¸ƒ',             int: [0, 4, 7, 11] },
  { id: 'min7',     name: 'å°ä¸ƒ',             int: [0, 3, 7, 10] },
  { id: 'dom7',     name: 'å±ä¸ƒ',          int: [0, 4, 7, 10] },
  { id: 'm7b5',     name: 'åŠå‡ä¸ƒ', int: [0, 3, 6, 10] },
  { id: 'dim7',     name: 'å‡ä¸ƒ',        int: [0, 3, 6, 9] },
  { id: 'maj9',     name: 'å¤§ä¹',             int: [0, 4, 7, 11, 14] },
  { id: 'sus2',     name: 'æŒ‚äºŒ',         int: [0, 2, 7] },
  { id: 'minMaj7',  name: 'å°å¤§ä¸ƒ',     int: [0, 3, 7, 11] },
  { id: 'aug7',     name: 'å¢ä¸ƒ',         int: [0, 4, 8, 10] },
  { id: 'dom7sus4', name: 'å±ä¸ƒæŒ‚å››',    int: [0, 5, 7, 10] },
  { id: 'min9',     name: 'å°ä¹',             int: [0, 3, 7, 10, 14] },
  { id: 'dom9',     name: 'å±ä¹',          int: [0, 4, 7, 10, 14] },
  { id: 'dom9sus4', name: 'å±ä¹æŒ‚å››',    int: [0, 5, 7, 10, 14] },
  { id: 'dom13',    name: 'å±åä¸‰',       int: [0, 4, 7, 10, 14, 21] },
  { id: 'add9',     name: 'åŠ ä¹',                  int: [0, 4, 7, 14] },
  { id: '6',        name: 'å…­å’Œå¼¦',           int: [0, 4, 7, 9] },
  { id: 'dom7b9',   name: 'å±ä¸ƒé™ä¹',      int: [0, 4, 7, 10, 13] },
  { id: 'dom7#9',   name: 'å±ä¸ƒå‡ä¹',      int: [0, 4, 7, 10, 15] }
];

    // --- çŠ¶æ€å˜é‡ ---
    let customChords = []; // æ–°å¢ï¼šè‡ªå®šä¹‰å’Œå¼¦åˆ—è¡¨
    let audioCtx;
    let userInteracted = false; // Brave/Chrome autoplay gate
    let isPlaying = false;
    let currentTab = 'interval-loop';
    let timeoutId = null;
    let activeOscs = [];
    let masterVolume = 0.5; // å…¨å±€éŸ³é‡ (0.0 - 1.0)
    
    // --- é‡‡æ ·å™¨æ•°æ® ---
    const INSTRUMENT_CONFIGS = {
        'piano': {
            label: 'é’¢ç´',
            base: "https://cdn.jsdelivr.net/gh/nbrosowsky/tonejs-instruments@master/samples/piano/",
        },
        'guitar-acoustic': {
            label: 'åŸå£°å‰ä»–',
            base: "https://cdn.jsdelivr.net/gh/nbrosowsky/tonejs-instruments@master/samples/guitar-acoustic/",
        },
        'guitar-electric': {
            label: 'ç”µå‰ä»–',
            base: "https://cdn.jsdelivr.net/gh/nbrosowsky/tonejs-instruments@master/samples/guitar-electric/",
        },
        'violin': {
            label: 'å°æç´',
            base: "https://cdn.jsdelivr.net/gh/nbrosowsky/tonejs-instruments@master/samples/violin/",
        }
    };
    // ç»Ÿä¸€çš„å…³é”®å¸§é‡‡æ ·æ˜ å°„ï¼ˆè·¨ä¹å™¨å¤ç”¨ï¼‰
    const SAMPLE_MAP = {
        36: "C2.mp3", 39: "Ds2.mp3", 42: "Fs2.mp3", 45: "A2.mp3",
        48: "C3.mp3", 51: "Ds3.mp3", 54: "Fs3.mp3", 57: "A3.mp3",
        60: "C4.mp3", 63: "Ds4.mp3", 66: "Fs4.mp3", 69: "A4.mp3",
        72: "C5.mp3", 75: "Ds5.mp3", 78: "Fs5.mp3", 81: "A5.mp3",
        84: "C6.mp3", 87: "Ds6.mp3", 90: "Fs6.mp3", 93: "A6.mp3",
        96: "C7.mp3", 99: "Ds7.mp3", 102: "Fs7.mp3", 105: "A7.mp3"
    };
    
    let samplerState = {
        buffers: {},     // { instrumentId: { midi: AudioBuffer } }
        loading: {},     // { instrumentId: boolean }
        loaded: {},      // { instrumentId: boolean }
        timbre: 'osc'    // 'osc' | instrumentId
    };

    // è¯­éŸ³æ”¯æŒ
    let availableVoices = [];
    function loadVoices() {
        if(!window.speechSynthesis) return;
        availableVoices = window.speechSynthesis.getVoices();
        console.log('[TTS] loadVoices ->', availableVoices.map(v=>`${v.name}(${v.lang})`));
    }
    // ç­‰å¾… voices å¯ç”¨ï¼Œé˜²æ­¢æœ‰äº›æµè§ˆå™¨é¦–æ¬¡ä¸ºç©º
    function ensureVoicesReady(timeout = 1200) {
        return new Promise(resolve => {
            loadVoices();
            if (availableVoices.length > 0) return resolve();
            
            const timer = setTimeout(() => {
                loadVoices();
                console.log('[TTS] ensureVoicesReady timeout, voices:', availableVoices.length);
                resolve();
            }, timeout);
            
            const handler = () => {
                loadVoices();
                clearTimeout(timer);
                window.speechSynthesis.onvoiceschanged = null;
                console.log('[TTS] onvoiceschanged fired, voices:', availableVoices.length);
                resolve();
            };
            window.speechSynthesis.onvoiceschanged = handler;
        });
    }
    if (window.speechSynthesis) {
        window.speechSynthesis.onvoiceschanged = loadVoices;
        // å°è¯•ç«‹å³åŠ è½½
        loadVoices();
    }

    // **æ–°å¢ï¼šé¡ºåºæ’­æ”¾çŠ¶æ€ç®¡ç†**
    let sequenceState = {
        active: false,
        queue: [],      // å¾…æ’­æ”¾çš„æ¨¡å¼åˆ—è¡¨ ['up', 'down', 'harm']
        index: 0,       // å½“å‰æ’­æ”¾åˆ°ç¬¬å‡ ä¸ª
        data: null      // é”å®šçš„éŸ³ç¬¦æ•°æ® { root: 60, notes: [60, 64, 67], name: "C Maj" }
    };
    
    // **æ–°å¢ï¼šå¾ªç¯æ¨¡å¼é‡å¤æ’­æ”¾çŠ¶æ€**
    let loopRepeatState = {
        count: 0,
        max: 1,
        lastData: null
    };
    
    // Tab 6 é”®ç›˜æ˜ å°„æ•°æ®
    const KEY_MAPPINGS = [
        { key: '1', semi: 1 }, { key: '2', semi: 2 }, { key: '3', semi: 3 }, { key: '4', semi: 4 },
        { key: '5', semi: 5 }, { key: '6', semi: 6 }, { key: '7', semi: 7 }, { key: '8', semi: 8 },
        { key: '9', semi: 9 }, { key: '0', semi: 10 }, { key: '-', semi: 11 }, { key: '=', semi: 12 }
    ];
    let currentKeyInt = null; // å½“å‰é”®ç›˜æ¨¡å¼é€‰ä¸­çš„éŸ³ç¨‹ {semi: 1, name: "..."}

    // --- åˆå§‹åŒ– ---
    window.onload = function() {
        initUI();
        initDragSort();
    };

    function initDragSort() {
        const containers = document.querySelectorAll('.sortable-list');
        containers.forEach(container => {
            container.addEventListener('dragstart', e => {
                if (e.target.classList.contains('sortable-item')) {
                    e.target.classList.add('dragging');
                }
            });
            
            container.addEventListener('dragend', e => {
                if (e.target.classList.contains('sortable-item')) {
                    e.target.classList.remove('dragging');
                    saveSettings(); // é¡ºåºæ”¹å˜åä¿å­˜
                }
            });
            
            container.addEventListener('dragover', e => {
                e.preventDefault();
                const afterElement = getDragAfterElement(container, e.clientX);
                const draggable = container.querySelector('.dragging');
                if (afterElement == null) {
                    container.appendChild(draggable);
                } else {
                    container.insertBefore(draggable, afterElement);
                }
            });
        });
    }

    function getDragAfterElement(container, x) {
        const draggableElements = [...container.querySelectorAll('.sortable-item:not(.dragging)')];
        
        return draggableElements.reduce((closest, child) => {
            const box = child.getBoundingClientRect();
            // æ£€æŸ¥æ°´å¹³ä¸­å¿ƒç‚¹
            const offset = x - box.left - box.width / 2;
            if (offset < 0 && offset > closest.offset) {
                return { offset: offset, element: child };
            } else {
                return closest;
            }
        }, { offset: Number.NEGATIVE_INFINITY }).element;
    }

    function initUI() {
        // 0. éŸ³é‡æ§åˆ¶
        const volSlider = document.getElementById('vol-slider');
        const volDisplay = document.getElementById('vol-display');
        
        volSlider.oninput = function() {
            masterVolume = parseFloat(this.value);
            volDisplay.innerText = Math.round(masterVolume * 100) + '%';
            saveSettings(); // éŸ³é‡å˜åŠ¨ä¹Ÿä¿å­˜
        };
        
        // 0.1 éŸ³è‰²æ§åˆ¶
        const timbreSel = document.getElementById('timbre-select');
        timbreSel.onchange = function() {
            samplerState.timbre = this.value;
            if(this.value !== 'osc' && !samplerState.loaded[this.value]) {
                loadInstrumentSamples(this.value);
            }
            saveSettings();
        };

        // 1. æ ¹éŸ³èŒƒå›´
        const minSel = document.getElementById('range-min');
        const maxSel = document.getElementById('range-max');
        for(let i=36; i<=96; i++) {
            let label = midiToName(i);
            minSel.add(new Option(label, i));
            maxSel.add(new Option(label, i));
        }
        minSel.value = 48; // C3
        maxSel.value = 84;

        // 2. æ ¹éŸ³éŸ³åè¿‡æ»¤ (C, C#, D...)
        const rootFilterContainer = document.getElementById('root-note-filter');
        NOTE_NAMES.forEach((name, idx) => {
            const div = document.createElement('div');
            div.className = 'note-check checked'; // é»˜è®¤å…¨é€‰
            div.innerText = name;
            div.dataset.val = idx;
            div.onclick = function() {
                this.classList.toggle('checked');
            };
            rootFilterContainer.appendChild(div);
        });

        // 3. å¡«å……éŸ³ç¨‹åˆ—è¡¨
        ['int-list-loop', 'int-list-quiz'].forEach(id => {
            const container = document.getElementById(id);
            INTERVALS.forEach(intObj => {
                const checked = intObj.semitones <= 12 ? 'checked' : '';
                const html = `<label><input type="checkbox" value="${intObj.semitones}" ${checked}> ${intObj.name}</label>`;
                container.innerHTML += html;
            });
        });

        // 4.5. å¡«å…… Tab 6 çš„æŒ‰é”®æ˜¾ç¤º
        const keyMapContainer = document.getElementById('key-map-display');
        KEY_MAPPINGS.forEach(km => {
            const intObj = INTERVALS.find(i => i.semitones === km.semi);
            const div = document.createElement('div');
            div.className = 'key-card';
            div.innerHTML = `<div style="font-weight:bold; font-size:1.2rem; color:var(--primary);">${km.key}</div><div style="font-size:0.8rem; color:var(--muted);">${intObj.name}</div>`;
            div.id = `key-card-${km.key}`; // ç”¨äºé«˜äº®
            
            // ç‚¹å‡»ä¹Ÿå¯ä»¥è§¦å‘
            div.onmousedown = function() { triggerKeyInterval(km.key); };
            
            keyMapContainer.appendChild(div);
        });

        // 4. å¡«å……å’Œå¼¦åˆ—è¡¨ (å·²ç§»è‡³ renderChordSelectors)
        renderChordSelectors();

        // ç»‘å®šæŒ‰é’®
        document.getElementById('btn-toggle').onclick = togglePlay;
        
        // ç»‘å®šç©ºæ ¼é”®å’ŒéŸ³é‡é”®
        const markUserGesture = () => {
            if (!userInteracted) {
                userInteracted = true;
                initAudio();
                console.log('[Audio] user gesture detected, audio unlocked');
            }
        };
        
        document.addEventListener('keydown', function(e) {
            if (e.target.tagName === 'INPUT') return; // è¾“å…¥æ¡†æ—¶ä¸è§¦å‘
            markUserGesture();

            if (e.code === 'Space') {
                e.preventDefault(); 
                togglePlay();
            } else if (e.code === 'ArrowUp') {
                e.preventDefault();
                adjustVolume(0.05);
            } else if (e.code === 'ArrowDown') {
                e.preventDefault();
                adjustVolume(-0.05);
            } else if (currentTab === 'keyboard-mode') {
                // é”®ç›˜æ¨¡å¼æŒ‰é”®å¤„ç†
                // å¤„ç† 1-9, 0, -, =
                const key = e.key; 
                // å…¼å®¹å¤„ç†ï¼šæœ‰äº›é”®ç›˜ - æ˜¯ Minus, = æ˜¯ Equal
                if (KEY_MAPPINGS.find(k => k.key === key)) {
                    e.preventDefault(); // é˜²æ­¢è§¦å‘æµè§ˆå™¨å¿«æ·é”®
                    triggerKeyInterval(key);
                }
            }
        });

        // 5. åŠ è½½ä¸Šæ¬¡ä¿å­˜çš„è®¾ç½®
        loadSettings();
        
        // 6. è‡ªåŠ¨ä¿å­˜ (é¡µé¢å…³é—­æˆ–åˆ·æ–°å‰)
        window.addEventListener('beforeunload', saveSettings);

        // 7. è§£é”éŸ³é¢‘çš„é€šç”¨æ‰‹åŠ¿ç»‘å®šï¼ˆé¼ æ ‡/è§¦æ‘¸ï¼‰
        ['mousedown','touchstart'].forEach(ev => {
            document.addEventListener(ev, markUserGesture, { once: true, passive: true });
        });
    }

    // --- æ•°æ®æŒä¹…åŒ– (æ–°å¢) ---
    const STORAGE_KEY = 'music_trainer_v2_settings';

    function saveSettings() {
        const settings = {};

        // 1. ä¿å­˜ç®€å•çš„ Input/Select/Checkbox (é€šè¿‡ ID)
        const ids = [
            'range-min', 'range-max', 
            'speed-loop', 'gap-loop', 'seq-mode-int', 'repeat-loop-int',
            'arp-speed-loop', 'chord-gap-loop', 'seq-mode-chord', 'inv-loop', 'double-loop', 'max-notes-loop', 'repeat-loop-chord', 'chord-dur-loop',
            'speak-root-int', 'quiz-int-mode', 'gap-quiz-int', 'repeat-quiz-int',
            'speak-root-chord', 'inv-quiz', 'gap-quiz-chord', 'repeat-quiz-chord',
            'note-dur-quiz', 'gap-quiz-note', 'repeat-quiz-note',
            'vol-slider', 'timbre-select', // ä¿å­˜éŸ³é‡å’ŒéŸ³è‰²
            'key-loop-mode', 'speed-key', 'gap-key' // Tab 6 è®¾ç½®
        ];
        ids.forEach(id => {
            const el = document.getElementById(id);
            if(el) {
                settings[id] = (el.type === 'checkbox') ? el.checked : el.value;
            }
        });

        // 2. ä¿å­˜ Tab
        settings.currentTab = currentTab;

        // 3. ä¿å­˜æ ¹éŸ³è¿‡æ»¤å™¨ (Note Selector)
        const rootNotes = [];
        document.querySelectorAll('#root-note-filter .note-check').forEach(el => {
            if(el.classList.contains('checked')) {
                rootNotes.push(parseInt(el.dataset.val));
            }
        });
        settings.rootNotes = rootNotes;

        // 4.5 ä¿å­˜è‡ªå®šä¹‰å’Œå¼¦
        settings.customChords = customChords;

        // 4. ä¿å­˜å„ç§åˆ—è¡¨å¤é€‰æ¡†
        settings.intListLoop = getCheckedValues('#int-list-loop input');
        // ä¿å­˜æ’åºåçš„é¡ºåº
        settings.playDirLoop = getOrderedValues('#sort-dir-loop'); 
        
        settings.chordListLoop = getCheckedValues('#chord-list-loop input');
        settings.chordDirLoop = getOrderedValues('#sort-dir-chord');
        
        settings.intListQuiz = getCheckedValues('#int-list-quiz input');
        settings.chordListQuiz = getCheckedValues('#chord-list-quiz input');
        settings.playDirKey = getOrderedValues('#sort-dir-key');

        localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));
    }

    function getCheckedValues(selector) {
        return Array.from(document.querySelectorAll(selector))
            .filter(el => el.checked)
            .map(el => el.value);
    }

    // è·å–æ’åºåçš„é€‰ä¸­å€¼
    function getOrderedValues(containerId) {
        const container = document.querySelector(containerId);
        if(!container) return [];
        return Array.from(container.querySelectorAll('.sortable-item'))
            .filter(item => item.querySelector('input').checked)
            .map(item => item.dataset.val);
    }
    
    // è·å–æ’åºåçš„æ‰€æœ‰ item å€¼ï¼ˆç”¨äºæ¢å¤é¡ºåºï¼‰
    function getOrderedAllItems(containerId) {
        const container = document.querySelector(containerId);
        if(!container) return [];
        return Array.from(container.querySelectorAll('.sortable-item')).map(item => item.dataset.val);
    }

    // ä¿å­˜å½“å‰ UI çš„é¡ºåºçŠ¶æ€
    function saveSortOrder(containerId) {
        return getOrderedAllItems(containerId);
    }

    function loadSettings() {
        const json = localStorage.getItem(STORAGE_KEY);
        if(!json) return;
        
        let settings;
        try { settings = JSON.parse(json); } catch(e) { return; }

        // --- æ¢å¤æ’åºé¡ºåº ---
        // æˆ‘ä»¬éœ€è¦é¢å¤–ä¿å­˜ä¸€ç§æ•°æ®ç»“æ„æ¥è®°å½•é¡ºåºï¼Œæˆ–è€…ç›´æ¥åˆ©ç”¨ saveSettings é‡Œä¿å­˜çš„é€‰ä¸­å€¼çš„é¡ºåºï¼Ÿ
        // å®é™…ä¸Š saveSettings åªä¿å­˜äº†é€‰ä¸­çš„å€¼å’Œå®ƒä»¬çš„é¡ºåºã€‚
        // å¦‚æœæˆ‘ä»¬åªç”¨ settings.playDirLoop æ¥æ¢å¤ï¼Œæœªé€‰ä¸­çš„é¡¹ä¼šä¸¢å¤±æˆ–è€…è·‘åˆ°æœ€åã€‚
        // ä¸ºäº†å®Œç¾ä½“éªŒï¼Œæˆ‘ä»¬æœ€å¥½ä¿å­˜å®Œæ•´çš„åˆ—è¡¨é¡ºåºã€‚
        // ä½†è¿™é‡Œä¸ºäº†ç®€åŒ–ï¼Œæˆ‘ä»¬å‡è®¾ç”¨æˆ·å…³å¿ƒçš„ä¸»è¦æ˜¯é€‰ä¸­çš„é¡¹çš„é¡ºåºã€‚
        // ä¸ºäº†ä¸¥è°¨ï¼Œæˆ‘ä»¬æ”¹è¿› saveSettings ç­–ç•¥ï¼š
        // åœ¨ saveSettings ä¸­ï¼Œæˆ‘ä»¬é™¤äº†ä¿å­˜é€‰ä¸­çš„å€¼ï¼Œè¿˜å¯ä»¥é¢å¤–ä¿å­˜ä¸€ä¸ª `Order` å­—æ®µã€‚
        // ä½†ç”±äºè¿™æ˜¯ä¸€ä¸ªçº¯å‰ç«¯å•æ–‡ä»¶ï¼Œæˆ‘ä»¬å¯ä»¥å°è¯•æ›´ç®€å•çš„åšæ³•ï¼š
        // åˆ©ç”¨ `settings.playDirLoop` (æ•°ç»„) çš„é¡ºåºæ¥é‡æ–°æ’åˆ— DOM å…ƒç´ ã€‚
        // é‚£äº›ä¸åœ¨ `settings.playDirLoop` ä¸­çš„å…ƒç´ ï¼ˆå³æœªé€‰ä¸­çš„ï¼‰ï¼Œæˆ‘ä»¬æŠŠå®ƒä»¬æ”¾åˆ°åé¢å»ã€‚

        if (settings.playDirLoop) restoreSortAndCheck('#sort-dir-loop', settings.playDirLoop);
        if (settings.chordDirLoop) restoreSortAndCheck('#sort-dir-chord', settings.chordDirLoop);
        if (settings.playDirKey) restoreSortAndCheck('#sort-dir-key', settings.playDirKey);

            // æ¢å¤ç®€å• ID
        for(let key in settings) {
            // è·³è¿‡å¤æ‚å¯¹è±¡
            if(['currentTab', 'rootNotes', 'intListLoop', 'playDirLoop', 'chordListLoop', 'chordDirLoop', 'intListQuiz', 'chordListQuiz', 'customChords', 'playDirKey'].includes(key)) continue;
            
            const el = document.getElementById(key);
            if(el) {
                if(el.type === 'checkbox') el.checked = settings[key];
                else el.value = settings[key];
                
                // ç‰¹æ®Šå¤„ç†éŸ³é‡æ¢å¤
                if(key === 'vol-slider') {
                    masterVolume = parseFloat(settings[key]);
                    document.getElementById('vol-display').innerText = Math.round(masterVolume * 100) + '%';
                }
                
                    // ç‰¹æ®Šå¤„ç†éŸ³è‰²æ¢å¤
                    if(key === 'timbre-select') {
                        samplerState.timbre = settings[key];
                        if(samplerState.timbre !== 'osc') loadInstrumentSamples(samplerState.timbre);
                    }
            }
        }

        // 0. æ¢å¤è‡ªå®šä¹‰å’Œå¼¦ (å¿…é¡»åœ¨æ¸²æŸ“åˆ—è¡¨ä¹‹å‰)
        if(settings.customChords && Array.isArray(settings.customChords)) {
            customChords = settings.customChords;
        }
        
        // é‡æ–°æ¸²æŸ“å’Œå¼¦åˆ—è¡¨ä»¥åŒ…å«è‡ªå®šä¹‰å’Œå¼¦
        renderChordSelectors();

        // æ¢å¤ Tab
        if(settings.currentTab) {
             const tabBtn = document.querySelector(`button[onclick="switchTab('${settings.currentTab}')"]`);
             if(tabBtn) tabBtn.click();
        }

        // æ¢å¤æ ¹éŸ³
        if(settings.rootNotes && Array.isArray(settings.rootNotes)) {
            document.querySelectorAll('#root-note-filter .note-check').forEach(el => {
                const val = parseInt(el.dataset.val);
                if(settings.rootNotes.includes(val)) el.classList.add('checked');
                else el.classList.remove('checked');
            });
        }

        // æ¢å¤åˆ—è¡¨å¤é€‰æ¡†
        restoreChecks('#int-list-loop input', settings.intListLoop);
        // restoreChecks('.play-dir-loop', settings.playDirLoop); // ç”± restoreSortAndCheck å¤„ç†
        restoreChecks('#chord-list-loop input', settings.chordListLoop);
        // restoreChecks('.chord-dir-loop', settings.chordDirLoop); // ç”± restoreSortAndCheck å¤„ç†
        restoreChecks('#int-list-quiz input', settings.intListQuiz);
        restoreChecks('#chord-list-quiz input', settings.chordListQuiz);
        // restoreChecks('.play-dir-key', settings.playDirKey); // ç”± restoreSortAndCheck å¤„ç†
    }

    function restoreSortAndCheck(containerSelector, orderedValues) {
        const container = document.querySelector(containerSelector);
        if (!container || !Array.isArray(orderedValues)) return;
        
        // 1. è·å–ç°æœ‰ DOM å…ƒç´  map
        const itemMap = {};
        const items = Array.from(container.querySelectorAll('.sortable-item'));
        items.forEach(item => {
            const val = item.dataset.val;
            itemMap[val] = item;
            // é»˜è®¤å…ˆè®¾ä¸ºä¸é€‰ä¸­ï¼Œåç»­æ ¹æ® orderedValues çŠ¶æ€æ¥ check
            // ä½†æ³¨æ„ï¼šorderedValues åªåŒ…å«é€‰ä¸­çš„å€¼ã€‚æ‰€ä»¥ä¸åœ¨ orderedValues é‡Œçš„æˆ‘ä»¬è¦è®¾ä¸º unchecked
            const cb = item.querySelector('input');
            if(cb) cb.checked = false; 
        });

        // 2. æ¸…ç©ºå®¹å™¨
        container.innerHTML = '';

        // 3. å…ˆæ·»åŠ æœ‰åºä¸”é€‰ä¸­çš„
        orderedValues.forEach(val => {
            const item = itemMap[val];
            if (item) {
                item.querySelector('input').checked = true;
                container.appendChild(item);
                delete itemMap[val]; // æ ‡è®°å·²å¤„ç†
            }
        });

        // 4. æ·»åŠ å‰©ä¸‹çš„ï¼ˆæœªé€‰ä¸­çš„ï¼‰
        for (let val in itemMap) {
            container.appendChild(itemMap[val]);
        }
    }

    function restoreChecks(selector, values) {
        if(!values || !Array.isArray(values)) return;
        document.querySelectorAll(selector).forEach(el => {
            el.checked = values.includes(el.value);
        });
    }

    function getAllChords() {
        return [...DEFAULT_CHORDS, ...customChords];
    }

    function renderChordSelectors() {
        const all = getAllChords();
        ['chord-list-loop', 'chord-list-quiz'].forEach(id => {
            const container = document.getElementById(id);
            // å¤‡ä»½å½“å‰é€‰ä¸­çŠ¶æ€
            const oldCheckedValues = Array.from(container.querySelectorAll('input:checked')).map(i => i.value);
            
            container.innerHTML = '';
            
            all.forEach(c => {
                let isChecked = false;
                if (oldCheckedValues.length > 0) {
                    isChecked = oldCheckedValues.includes(c.id);
                } else {
                    // åˆå§‹é»˜è®¤é€‰ä¸­ maj å’Œ min
                    isChecked = ['maj','min'].includes(c.id);
                }
                
                let labelHtml = `${c.name}`;
                if (c.isCustom) {
                    // è‡ªå®šä¹‰å’Œå¼¦æ˜¾ç¤ºåˆ é™¤æŒ‰é’®
                    labelHtml += ` <span style="color:red; font-weight:bold; margin-left:5px; cursor:pointer;" title="åˆ é™¤" onclick="removeCustomChord('${c.id}', event)">Ã—</span>`;
                } else {
                    labelHtml += ` (${c.id})`;
                }

                const div = document.createElement('div');
                div.innerHTML = `<label style="display:inline-flex; align-items:center; width:100%;">
                    <input type="checkbox" value="${c.id}" ${isChecked ? 'checked' : ''}> 
                    <span style="flex:1">${labelHtml}</span>
                </label>`;
                container.appendChild(div.firstElementChild);
            });
        });
    }

    function addCustomChord() {
        const nameInput = document.getElementById('new-chord-name');
        const intInput = document.getElementById('new-chord-int');
        
        const name = nameInput.value.trim();
        const intStr = intInput.value.trim();
        
        if(!name || !intStr) { alert("è¯·è¾“å…¥åç§°å’ŒéŸ³ç¨‹"); return; }
        
        // è§£æéŸ³ç¨‹
        let intervals = [];
        try {
            intervals = intStr.split(/[,ï¼Œ\s]+/).map(s => parseInt(s));
            if(intervals.some(isNaN)) throw new Error();
        } catch(e) {
            alert("éŸ³ç¨‹æ ¼å¼é”™è¯¯ï¼Œè¯·ä½¿ç”¨æ•°å­—å’Œé€—å·ï¼Œå¦‚: 0,4,7");
            return;
        }
        
        // åˆ›å»º ID
        const id = 'cust_' + Date.now();
        
        customChords.push({
            id: id,
            name: name,
            int: intervals,
            isCustom: true
        });
        
        nameInput.value = '';
        intInput.value = '';
        
        renderChordSelectors();
        saveSettings(); // ä¿å­˜
    }

    window.removeCustomChord = function(id, event) {
        event.preventDefault();
        event.stopPropagation();
        if(!confirm("ç¡®å®šåˆ é™¤è¿™ä¸ªè‡ªå®šä¹‰å’Œå¼¦å—ï¼Ÿ")) return;
        
        customChords = customChords.filter(c => c.id !== id);
        renderChordSelectors();
        saveSettings();
    }

    window.adjustVolume = function(delta) {
        masterVolume = Math.min(1.0, Math.max(0.0, masterVolume + delta));
        document.getElementById('vol-slider').value = masterVolume;
        document.getElementById('vol-display').innerText = Math.round(masterVolume * 100) + '%';
        saveSettings();
        
        // å¯é€‰ï¼šæ’­æ”¾ä¸€ä¸ªçŸ­éŸ³æç¤ºéŸ³é‡
        // if(audioCtx && audioCtx.state === 'running') playTone(440, audioCtx.currentTime, 0.1, 0.1); 
    }

    function triggerKeyInterval(key) {
        const mapping = KEY_MAPPINGS.find(k => k.key === key);
        if(!mapping) return;
        
        // é«˜äº® UI
        document.querySelectorAll('.key-card').forEach(el => el.style.background = '#fff');
        const card = document.getElementById(`key-card-${key}`);
        if(card) card.style.background = '#ffeaa7';

        const intObj = INTERVALS.find(i => i.semitones === mapping.semi);
        currentKeyInt = intObj;

        // å¦‚æœæ˜¯åœæ­¢çŠ¶æ€ï¼Œå¼€å§‹æ’­æ”¾
        // å¦‚æœæ˜¯æ’­æ”¾çŠ¶æ€ï¼Œç«‹å³åˆ‡æ­Œ (é‡ç½®)
        if (!isPlaying) {
             start(); // start ä¼šè°ƒç”¨ nextRound(0) -> è·¯ç”±åˆ° logicKeyboardMode
        } else {
            // å¼ºåˆ¶é‡å¼€ä¸€è½®ï¼Œå®ç°â€œç«‹å³åˆ‡æ¢â€
            clearTimeout(timeoutId);
            activeOscs.forEach(o => { try{o.stop()}catch(e){} });
            activeOscs = [];
            // å¦‚æœå·²ç»åœ¨æ’­æ”¾ä¸”åªæ˜¯åˆ‡æ¢éŸ³ç¨‹ï¼Œæˆ‘ä»¬ä¿æŒ isPlaying = trueï¼Œç›´æ¥è°ƒ nextRound
            nextRound(0);
        }
    }

    // --- Tab åˆ‡æ¢ ---
    window.switchTab = function(tabId) {
        if(isPlaying) stop();
        currentTab = tabId;
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.content').forEach(c => c.classList.remove('active'));
        
        event.target.classList.add('active');
        document.getElementById(tabId).classList.add('active');
        updateStatus("å‡†å¤‡å°±ç»ª", "");
    };

    function setChecks(containerId, state) {
        const inputs = document.querySelectorAll(`#${containerId} input[type="checkbox"]`);
        inputs.forEach(i => i.checked = state);
    }

    function toggleChecks(containerId) {
        const inputs = document.querySelectorAll(`#${containerId} input[type="checkbox"]`);
        inputs.forEach(i => i.checked = !i.checked);
    }
    
    window.toggleAllNotes = function() {
        const notes = document.querySelectorAll('.note-check');
        const anyUnchecked = Array.from(notes).some(n => !n.classList.contains('checked'));
        notes.forEach(n => anyUnchecked ? n.classList.add('checked') : n.classList.remove('checked'));
    }

    // --- éŸ³é¢‘å¼•æ“ ---
    function initAudio() {
        // å¿…é¡»åœ¨ç”¨æˆ·æ‰‹åŠ¿åè°ƒç”¨ï¼Œå¦åˆ™ Brave/Chromium ä¼šé˜»æ­¢
        if (!userInteracted) {
            console.warn('[Audio] initAudio skipped, waiting for user gesture');
            return null;
        }
        if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if(audioCtx.state === 'suspended') {
            audioCtx.resume().catch(err => console.warn('[Audio] resume failed', err));
        }
        return audioCtx;
    }

    // --- é‡‡æ ·å™¨é€»è¾‘ ---
    async function loadInstrumentSamples(instrumentId) {
        if(instrumentId === 'osc') return;
        if(samplerState.loaded[instrumentId] || samplerState.loading[instrumentId]) return;
        
        // è‹¥æ— ç”¨æˆ·æ‰‹åŠ¿ï¼Œè·³è¿‡ï¼Œå¾…ç”¨æˆ·æ“ä½œåå†åŠ è½½
        if (!initAudio()) {
            console.warn('[Audio] loadInstrumentSamples postponed until user gesture');
            return;
        }
        const cfg = INSTRUMENT_CONFIGS[instrumentId];
        if(!cfg) { console.warn('Unknown instrument', instrumentId); return; }
        
        samplerState.loading[instrumentId] = true;
        
        // UI åé¦ˆ
        const sel = document.getElementById('timbre-select');
        if(sel) sel.disabled = true;
        updateStatus(`â³ æ­£åœ¨ä¸‹è½½${cfg.label}éŸ³è‰²...`, "é¦–æ¬¡åŠ è½½éœ€è¦å‡ ç§’é’Ÿ (çº¦2MB)");
        
        if(!samplerState.buffers[instrumentId]) samplerState.buffers[instrumentId] = {};
        
        const promises = Object.entries(SAMPLE_MAP).map(async ([midi, filename]) => {
            try {
                const response = await fetch(cfg.base + filename);
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                samplerState.buffers[instrumentId][midi] = audioBuffer;
            } catch(e) {
                console.warn(`Failed to load sample ${instrumentId} ${midi}:`, e);
            }
        });
        
        try {
            await Promise.all(promises);
            samplerState.loaded[instrumentId] = true;
        updateStatus(`${cfg.label}éŸ³è‰²å°±ç»ª`, "å¼€å§‹è®­ç»ƒå§");
        } catch(e) {
            alert("éŸ³è‰²åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ");
            samplerState.timbre = 'osc';
            if(sel) sel.value = 'osc';
        } finally {
            samplerState.loading[instrumentId] = false;
            if(sel) sel.disabled = false;
        }
    }

    function midiToName(midi) {
        const note = NOTE_NAMES[midi % 12];
        const oct = Math.floor(midi/12) - 1;
        return `${note}${oct}`;
    }

    function playTone(freq, start, dur, vol=0.5) {
        // ... åŸæœ‰çš„åˆæˆå™¨é€»è¾‘ ...
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'triangle';
        osc.frequency.value = freq;
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        
        // åº”ç”¨å…¨å±€éŸ³é‡
        const finalVol = vol * masterVolume;

        gain.gain.setValueAtTime(0, start);
        gain.gain.linearRampToValueAtTime(finalVol, start + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.001, start + dur);
        
        osc.start(start);
        osc.stop(start + dur + 0.1);
        activeOscs.push(osc);
    }

    function playSampleNote(targetMidi, start, durMs, vol=0.5) {
        const inst = samplerState.timbre;
        const instBuffers = samplerState.buffers[inst];
        if(!instBuffers) return;

        // 1. å¯»æ‰¾æœ€è¿‘çš„é‡‡æ ·
        let nearestMidi = -1;
        let minDist = 999;
        
        for(let m in instBuffers) {
            const dist = Math.abs(targetMidi - m);
            if(dist < minDist) {
                minDist = dist;
                nearestMidi = parseInt(m);
            }
        }
        
        if(nearestMidi === -1) return; // æœªåŠ è½½æˆ–åŠ è½½å¤±è´¥
        
        const buffer = instBuffers[nearestMidi];
        const source = audioCtx.createBufferSource();
        source.buffer = buffer;
        
        // 2. å˜è°ƒ: 2^(delta/12)
        const detune = (targetMidi - nearestMidi) * 100;
        source.detune.value = detune;
        
        // 3. åŒ…ç»œ
        const gainNode = audioCtx.createGain();
        source.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        
        const finalVol = vol * masterVolume * 1.5; // é’¢ç´é‡‡æ ·é€šå¸¸æ¯”åˆæˆå™¨å°ï¼Œç¨å¾®æ”¾å¤§
        const durSec = durMs / 1000;
        
        gainNode.gain.setValueAtTime(0, start);
        gainNode.gain.linearRampToValueAtTime(finalVol, start + 0.02);
        // å¹¶åœ¨ç»“æŸæ—¶å¿«é€Ÿè¡°å‡ï¼Œé˜²æ­¢å’”å“’å£°
        gainNode.gain.setValueAtTime(finalVol, start + durSec); 
        gainNode.gain.exponentialRampToValueAtTime(0.001, start + durSec + 0.2);
        
        source.start(start);
        source.stop(start + durSec + 0.5); // å¤šç•™ä¸€ç‚¹å°¾éŸ³
    }

    function playNote(midi, start, durMs, vol=0.5) {
        if (samplerState.timbre !== 'osc' && samplerState.loaded[samplerState.timbre]) {
            playSampleNote(midi, start, durMs, vol);
        } else {
            // å›é€€åˆ°åˆæˆå™¨
            const freq = 440 * Math.pow(2, (midi-69)/12);
            playTone(freq, start, durMs/1000, vol);
        }
    }

    function translateToEnglish(text) {
        // ç®€å•å…³é”®å­—æ›¿æ¢ï¼Œä¾¿äºè‹±æ–‡è¯­éŸ³æœ—è¯»
        const map = [
            ['å°', 'minor '],
            ['å¤§', 'major '],
            ['å¢', 'augmented '],
            ['å‡', 'diminished '],
            ['å±', 'dominant '],
            ['çº¯', 'perfect '],
            ['æŒ‚å››', 'sus4'],
            ['æŒ‚äºŒ', 'sus2'],
            ['å’Œå¼¦', ''],
            ['éŸ³ç¨‹', 'interval'],
            ['éŸ³', ''],
            ['åº¦', ''],
            ['å‡', 'sharp '],
            ['é™', 'flat '],
            ['åäº”', '15'],
            ['åä¸‰', '13'],
            ['åäºŒ', '12'],
            ['åä¸€', '11'],
            ['å', '10'],
            ['ä¹', '9'],
            ['å…«', '8'],
            ['ä¸ƒ', '7'],
            ['å…­', '6'],
            ['äº”', '5'],
            ['å››', '4'],
            ['ä¸‰', '3'],
            ['äºŒ', '2'],
            ['ä¸€', '1'],
        ];
        let t = text;
        map.forEach(([cn, en]) => { t = t.replace(new RegExp(cn, 'g'), en); });
        // å»æ‰å¤šä½™ç©ºæ ¼
        return t.replace(/\s+/g, ' ').trim() || text;
    }

    async function speak(text) {
        if(!window.speechSynthesis) {
            console.warn('[TTS] speechSynthesis not supported');
            return;
        }
        // æŸäº›æµè§ˆå™¨åœ¨æœªäº’åŠ¨æˆ–é¡µé¢åˆ‡åå°åä¼šæš‚åœï¼Œéœ€è¦å…ˆ resume
        try { window.speechSynthesis.resume(); } catch(e) { console.warn('[TTS] resume failed', e); }
        await ensureVoicesReady();
        if (availableVoices.length === 0) {
            // å†ç­‰ä¸€è½®æ›´é•¿çš„æ—¶é—´
            await ensureVoicesReady(3000);
        }
        window.speechSynthesis.cancel();
        
        const u = new SpeechSynthesisUtterance(text);
        
        // å°è¯•åŠ è½½è¯­éŸ³ï¼ˆå¦‚æœå°šæœªåŠ è½½ï¼‰
        if(availableVoices.length === 0) loadVoices();
        
        // æŸ¥æ‰¾ä¸­æ–‡è¯­éŸ³
        const zhVoice = availableVoices.find(v => v.lang && (v.lang.includes('zh') || v.lang.includes('CN')));
        const enVoice = availableVoices.find(v => v.lang && v.lang.toLowerCase().startsWith('en'));
        let finalText = text;
        if (zhVoice) {
            u.voice = zhVoice;
            u.lang = zhVoice.lang || 'zh-CN';
            console.log('[TTS] using zh voice', zhVoice.name, zhVoice.lang);
        } else if (enVoice) {
            u.voice = enVoice;
            u.lang = enVoice.lang || 'en-US';
            finalText = translateToEnglish(text);
            console.warn('[TTS] no zh voice found, using en voice', enVoice.name, enVoice.lang, 'translated:', finalText);
        } else {
            u.lang = 'en-US'; // fallback é˜²æ­¢ç©º
            finalText = translateToEnglish(text);
            console.warn('[TTS] no zh/en voice found, using default lang en-US, translated:', finalText);
        }
        
        u.rate = 1.0;
        console.log('[TTS] speak:', finalText, 'lang:', u.lang);
        u.text = finalText;
        window.speechSynthesis.speak(u);
    }

    // --- æ ¸å¿ƒé€»è¾‘ ---

    function togglePlay() {
        if (isPlaying) {
            stop();
        } else {
            start();
        }
    }

    function start() {
        if(isPlaying) return;
        initAudio();
        isPlaying = true;
        
        // é‡ç½®é¡ºåºæ’­æ”¾çŠ¶æ€
        sequenceState = { active: false, queue: [], index: 0, data: null };
        loopRepeatState = { count: 0, max: 1, lastData: null };

        const btn = document.getElementById('btn-toggle');
        btn.innerText = "åœæ­¢ (Space)";
        btn.className = "btn btn-stop";
        
        nextRound(0);
    }

    function stop() {
        isPlaying = false;
        clearTimeout(timeoutId);
        window.speechSynthesis.cancel();
        activeOscs.forEach(o => { try{o.stop()}catch(e){} });
        activeOscs = [];
        
        const btn = document.getElementById('btn-toggle');
        btn.innerText = "å¼€å§‹è®­ç»ƒ (Space)";
        btn.className = "btn btn-start";
        
        updateStatus("å·²åœæ­¢", "");
    }

    function updateStatus(main, sub) {
        const box = document.getElementById('status-display');
        box.innerHTML = `<div class="main-text">${main}</div><div class="sub-text">${sub}</div>`;
    }

    function getValidRoot() {
        // å¤„ç†å¼‚å¸¸ï¼šlocalStorage æ—§å€¼å¯èƒ½ä¸ºç©º/NaN
        let min = parseInt(document.getElementById('range-min').value);
        let max = parseInt(document.getElementById('range-max').value);
        if (Number.isNaN(min)) min = 48; // C3
        if (Number.isNaN(max)) max = 84; // C6
        if (min > max) [min, max] = [max, min]; // é˜²æ­¢ä¸Šä¸‹é™åè½¬

        const allowedPCs = Array.from(document.querySelectorAll('.note-check.checked')).map(el => parseInt(el.dataset.val));
        if(allowedPCs.length === 0) return null;

        let pool = [];
        for(let i=min; i<=max; i++) {
            if(allowedPCs.includes(i % 12)) pool.push(i);
        }
        if(pool.length === 0) return null;
        return pool[Math.floor(Math.random() * pool.length)];
    }

    function nextRound(delay) {
        if(!isPlaying) return;
        timeoutId = setTimeout(() => {
            if(!isPlaying) return;
            switch(currentTab) {
                case 'interval-loop': logicIntervalLoop(); break;
                case 'chord-loop': logicChordLoop(); break;
                case 'interval-quiz': logicIntervalQuiz(); break;
                case 'chord-quiz': logicChordQuiz(); break;
                case 'note-quiz': logicNoteQuiz(); break;
                case 'keyboard-mode': logicKeyboardMode(); break;
            }
        }, delay);
    }

    // --- é€»è¾‘ 6: é”®ç›˜æ§åˆ¶æ¨¡å¼ ---
    function logicKeyboardMode() {
        if (!currentKeyInt) {
            updateStatus("è¯·æŒ‰é”® 1-0, -, =", "é€‰æ‹©ä¸€ä¸ªéŸ³ç¨‹å¼€å§‹æ’­æ”¾");
            // å“ªæ€•æ²¡æœ‰é€‰ï¼Œå¦‚æœç”¨æˆ·å·²ç»ç‚¹äº† Startï¼Œæˆ‘ä»¬ä¹Ÿå¾—æŒ‚èµ·æˆ–è€… Stop?
            // æœ€å¥½æ˜¯ä¿æŒè¿è¡Œä½†æç¤º
            if(isPlaying) nextRound(500); 
            return;
        }

        const isLoop = document.getElementById('key-loop-mode').checked;
        const root = getValidRoot();
        if(root === null) { alert("æ— æœ‰æ•ˆæ ¹éŸ³"); stop(); return; }
        
        const note2 = root + currentKeyInt.semitones;
        const intName = currentKeyInt.name;

        // æ–¹å‘
        const dirs = getOrderedValues('#sort-dir-key'); // è·å–æ’åºåçš„é€‰ä¸­é¡¹
        if(dirs.length === 0) { alert("è¯·é€‰æ‹©æ–¹å‘"); stop(); return; }
        const mode = dirs[Math.floor(Math.random()*dirs.length)];

        // æ’­æ”¾
        const speed = parseInt(document.getElementById('speed-key').value);
        const gap = parseFloat(document.getElementById('gap-key').value) * 1000;
        const now = audioCtx.currentTime;
        let dur = 0;

        if(mode === 'asc') {
            playNote(root, now, speed);
            playNote(note2, now + speed/1000, speed);
            dur = speed * 2;
        } else if(mode === 'desc') {
            playNote(note2, now, speed);
            playNote(root, now + speed/1000, speed);
            dur = speed * 2;
        } else {
            playNote(root, now, speed*1.5);
            playNote(note2, now, speed*1.5);
            dur = speed * 1.5;
        }

        updateStatus(`${midiToName(root)} -> ${intName}`, `æ¨¡å¼: ${mode} ${isLoop ? '(å¾ªç¯)' : '(å•æ¬¡)'}`);

        // å†³å®šä¸‹ä¸€è½®
        if (isLoop) {
            nextRound(dur + gap);
        } else {
            // å•æ¬¡æ¨¡å¼ï¼šæ’­æ”¾å®Œåè‡ªåŠ¨åœæ­¢
            // æˆ‘ä»¬ä¸èƒ½ç«‹å³è°ƒ stop()ï¼Œå¦åˆ™å£°éŸ³ä¼šè¢«åˆ‡æ–­
            // ä½¿ç”¨ timeout åœ¨å£°éŸ³ç»“æŸå stop
            timeoutId = setTimeout(() => {
                stop();
            }, dur + gap + 100);
        }
    }

    // --- é€»è¾‘ 1: éŸ³ç¨‹å¾ªç¯ (ä¿®æ”¹ç‰ˆ) ---
    function logicIntervalLoop() {
        // 0. æ£€æŸ¥æ˜¯å¦å¤„äºé‡å¤çŠ¶æ€
        let root, semitones, mode, intName, note2;
        
        // å¦‚æœæ­£åœ¨é‡å¤ä¸­
        if (loopRepeatState.count < loopRepeatState.max && loopRepeatState.lastData) {
            ({ root, semitones, mode, intName, note2 } = loopRepeatState.lastData);
            loopRepeatState.count++;
        } else {
            // éœ€è¦ç”Ÿæˆæ–°çš„ (æˆ–æ¨è¿›åºåˆ—)
            
            // 1. æ£€æŸ¥æ˜¯å¦å¼€å¯äº†é¡ºåºæ’­æ”¾æ¨¡å¼
            const isSeqMode = document.getElementById('seq-mode-int').checked;
            let isNewGroup = false;

            // 2. çŠ¶æ€åˆ¤æ–­
            // å¦‚æœå¼€å¯äº†é¡ºåºæ¨¡å¼ï¼Œä¸”é˜Ÿåˆ—è¿˜æœ‰å‰©ä½™
            if (isSeqMode && sequenceState.queue.length > 0 && sequenceState.index < sequenceState.queue.length) {
                // -- ç»§ç»­æ’­æ”¾åºåˆ— --
                root = sequenceState.data.root;
                semitones = sequenceState.data.semitones;
                intName = sequenceState.data.name;
                mode = sequenceState.queue[sequenceState.index];
                sequenceState.index++; // æ­¥è¿›
                note2 = root + semitones;
            } else {
                // -- æ–°çš„ä¸€è½® --
                isNewGroup = true;
                root = getValidRoot();
                if(root === null) { alert("æ— æœ‰æ•ˆæ ¹éŸ³"); stop(); return; }

                const checkedInts = Array.from(document.querySelectorAll('#int-list-loop input:checked'));
                if(checkedInts.length === 0) { alert("è¯·é€‰æ‹©éŸ³ç¨‹"); stop(); return; }
                semitones = parseInt(checkedInts[Math.floor(Math.random()*checkedInts.length)].value);
                intName = INTERVALS.find(i => i.semitones === semitones).name;
                note2 = root + semitones;

                const dirs = getOrderedValues('#sort-dir-loop'); // è·å–æ’åºåçš„é€‰ä¸­é¡¹
                if(dirs.length === 0) { alert("è¯·é€‰æ‹©æ–¹å‘"); stop(); return; }
                
                if (isSeqMode) {
                    sequenceState.queue = dirs;
                    sequenceState.index = 0;
                    sequenceState.data = { root, semitones, name: intName };
                    
                    mode = sequenceState.queue[sequenceState.index];
                    sequenceState.index++;
                } else {
                    sequenceState.queue = [];
                    // éšæœºæ¨¡å¼æ˜¯å¦ä¹Ÿè¦éµå¾ªæƒé‡çš„éšæœºï¼ŸåŸé€»è¾‘æ˜¯çº¯éšæœºã€‚
                    // ä¿æŒçº¯éšæœºï¼Œæˆ–è€…å¯ä»¥æŒ‰é¡ºåºéšæœºï¼Ÿè¿™é‡Œä¿æŒçº¯éšæœº
                    mode = dirs[Math.floor(Math.random()*dirs.length)];
                }
            }
            
            // åˆå§‹åŒ–é‡å¤çŠ¶æ€
            const repeatInput = parseInt(document.getElementById('repeat-loop-int').value) || 1;
            loopRepeatState.max = repeatInput;
            loopRepeatState.count = 1; // ç¬¬ä¸€æ¬¡æ’­æ”¾
            loopRepeatState.lastData = { root, semitones, mode, intName, note2 };
        }
        
        // 3. æ’­æ”¾é€»è¾‘ (ä¿æŒä¸å˜)
        const speed = parseInt(document.getElementById('speed-loop').value);
        const gap = parseFloat(document.getElementById('gap-loop').value) * 1000;
        const now = audioCtx.currentTime;
        let dur = 0;

        if(mode === 'asc') {
            playNote(root, now, speed);
            playNote(note2, now + speed/1000, speed);
            dur = speed * 2;
        } else if(mode === 'desc') {
            playNote(note2, now, speed);
            playNote(root, now + speed/1000, speed);
            dur = speed * 2;
        } else {
            playNote(root, now, speed*1.5);
            playNote(note2, now, speed*1.5);
            dur = speed * 1.5;
        }

        // 4. æ˜¾ç¤ºæ›´æ–°
        const isSeqMode = document.getElementById('seq-mode-int').checked;
        let seqTag = "";
        if (isSeqMode) {
            seqTag = `<span class="seq-tag">åºåˆ— ${sequenceState.index}/${sequenceState.queue.length}</span>`;
        }
        
        let repeatTag = "";
        if (loopRepeatState.max > 1) {
            repeatTag = `<span class="seq-tag" style="background:#6c5ce7">é‡å¤ ${loopRepeatState.count}/${loopRepeatState.max}</span>`;
        }

        updateStatus(`${midiToName(root)} -> ${intName} ${seqTag} ${repeatTag}`, `æ¨¡å¼: ${mode}`);
        
        nextRound(dur + gap);
    }

    // --- é€»è¾‘ 2: å’Œå¼¦å¾ªç¯ (ä¿®æ”¹ç‰ˆ) ---
    function logicChordLoop() {
        let root, chordObj, notes, mode;
        
        if (loopRepeatState.count < loopRepeatState.max && loopRepeatState.lastData) {
             ({ root, chordObj, notes, mode } = loopRepeatState.lastData);
             loopRepeatState.count++;
        } else {
            const isSeqMode = document.getElementById('seq-mode-chord').checked;
            
            // åˆ¤æ–­æ˜¯ç»§ç»­æ’­æ”¾åºåˆ—è¿˜æ˜¯ç”Ÿæˆæ–°çš„
            if (isSeqMode && sequenceState.queue.length > 0 && sequenceState.index < sequenceState.queue.length) {
                // ç»§ç»­åºåˆ—
                root = sequenceState.data.root;
                chordObj = sequenceState.data.chordObj;
                notes = sequenceState.data.notes; 
                mode = sequenceState.queue[sequenceState.index];
                sequenceState.index++;
            } else {
                // ç”Ÿæˆæ–°çš„
                root = getValidRoot();
                if(root === null) { stop(); return; }

                const checkedChords = Array.from(document.querySelectorAll('#chord-list-loop input:checked')).map(c=>c.value);
                if(checkedChords.length === 0) { alert("è¯·é€‰æ‹©å’Œå¼¦"); stop(); return; }
                
                const typeId = checkedChords[Math.floor(Math.random()*checkedChords.length)];
                chordObj = getAllChords().find(c => c.id === typeId);

                // ç”Ÿæˆ Voicing
                let rawNotes = chordObj.int.map(i => root + i);
                const allowInv = document.getElementById('inv-loop').checked;
                const allowDouble = document.getElementById('double-loop').checked;
                const maxNotes = parseInt(document.getElementById('max-notes-loop').value);
                
                if(allowDouble && Math.random() > 0.4 && rawNotes.length < maxNotes) rawNotes.push(root+12);
                if(allowInv && Math.random() > 0.5) {
                    rawNotes[0] += 12;
                    rawNotes.sort((a,b)=>a-b);
                }
                notes = rawNotes.slice(0, maxNotes);

                // ç¡®å®šæ–¹å‘
                const modes = getOrderedValues('#sort-dir-chord'); // è·å–æ’åºåçš„é€‰ä¸­é¡¹
                if(modes.length === 0) { alert("è¯·é€‰æ‹©æ¨¡å¼"); stop(); return; }

                if (isSeqMode) {
                    sequenceState.queue = modes; 
                    sequenceState.index = 0;
                    sequenceState.data = { root, chordObj, notes };
                    
                    mode = sequenceState.queue[sequenceState.index];
                    sequenceState.index++;
                } else {
                    sequenceState.queue = [];
                    mode = modes[Math.floor(Math.random()*modes.length)];
                }
            }
            
            // Init Repeat
            const repeatInput = parseInt(document.getElementById('repeat-loop-chord').value) || 1;
            loopRepeatState.max = repeatInput;
            loopRepeatState.count = 1;
            loopRepeatState.lastData = { root, chordObj, notes, mode };
        }

        const speed = parseInt(document.getElementById('arp-speed-loop').value);
        const chordDur = parseInt(document.getElementById('chord-dur-loop').value) || 1200;
        const gap = parseFloat(document.getElementById('chord-gap-loop').value) * 1000;
        const now = audioCtx.currentTime;
        let dur = 0;

        if(mode === 'harmonic') {
            notes.forEach(n => playNote(n, now, chordDur, 0.6/notes.length));
            dur = chordDur;
        } else if (mode === 'up') {
            notes.forEach((n,i) => playNote(n, now + i*speed/1000, speed+100));
            dur = notes.length * speed + 100;
        } else {
            [...notes].reverse().forEach((n,i) => playNote(n, now + i*speed/1000, speed+100));
            dur = notes.length * speed + 100;
        }

        const isSeqMode = document.getElementById('seq-mode-chord').checked;
        let seqTag = "";
        if (isSeqMode) {
            seqTag = `<span class="seq-tag">åºåˆ— ${sequenceState.index}/${sequenceState.queue.length}</span>`;
        }
        
        let repeatTag = "";
        if (loopRepeatState.max > 1) {
            repeatTag = `<span class="seq-tag" style="background:#6c5ce7">é‡å¤ ${loopRepeatState.count}/${loopRepeatState.max}</span>`;
        }

        updateStatus(`${midiToName(root)} ${chordObj.name} ${seqTag} ${repeatTag}`, `éŸ³: ${notes.map(midiToName).join(' ')} (${mode})`);
        nextRound(dur + gap);
    }

    // --- é€»è¾‘ 3, 4, 5 (ä¿®æ”¹ç‰ˆï¼šæ”¯æŒé‡å¤æ’­æ”¾) ---
    function logicIntervalQuiz(existingData = null) {
        let root, semitones, note2, intName, mode, remainingRepeats;
        
        if (existingData) {
            ({root, semitones, note2, intName, mode, remainingRepeats} = existingData);
        } else {
            root = getValidRoot();
            if(!root) { stop(); return; }
            
            const checkedInts = Array.from(document.querySelectorAll('#int-list-quiz input:checked'));
            if(checkedInts.length === 0) { alert("é€‰éŸ³ç¨‹"); stop(); return; }
            
            semitones = parseInt(checkedInts[Math.floor(Math.random()*checkedInts.length)].value);
            note2 = root + semitones;
            intName = INTERVALS.find(i => i.semitones === semitones).name;

            mode = document.getElementById('quiz-int-mode').value;
            if(mode === 'random') mode = ['asc','desc','harm'][Math.floor(Math.random()*3)];
            
            remainingRepeats = (parseInt(document.getElementById('repeat-quiz-int').value) || 1) - 1;
        }

        const speakTextInt = intName.split(' ')[0]; 
        const speed = 500;
        const now = audioCtx.currentTime;
        let dur = 0;

        if(mode === 'asc') {
            playNote(root, now, speed);
            playNote(note2, now + speed/1000, speed);
            dur = speed * 2;
        } else if(mode === 'desc') {
            playNote(note2, now, speed);
            playNote(root, now + speed/1000, speed);
            dur = speed * 2;
        } else {
            playNote(root, now, 1000);
            playNote(note2, now, 1000);
            dur = 1000;
        }

        updateStatus("ğŸ§ å¬è¾¨ä¸­...", `ç­‰å¾…è¯­éŸ³æ­æ™“... (å‰©ä½™é‡å¤: ${remainingRepeats})`);

        if (remainingRepeats > 0) {
            // ç»§ç»­é‡å¤æ’­æ”¾é¢˜ç›®
            setTimeout(() => {
                if(!isPlaying) return;
                logicIntervalQuiz({root, semitones, note2, intName, mode, remainingRepeats: remainingRepeats - 1});
            }, dur + 600); // é—´éš”
        } else {
            // æ’­æ”¾å®Œæ¯•ï¼Œæ­æ™“ç­”æ¡ˆ
            setTimeout(() => {
                if(!isPlaying) return;
                const speakRoot = document.getElementById('speak-root-int').checked;
                const rootName = NOTE_NAMES[root % 12];
                let text = speakRoot ? `${rootName} ${speakTextInt}` : speakTextInt;
                speak(text);
                updateStatus(`ç­”æ¡ˆ: ${text}`, `(éŸ³ç¨‹: ${intName})`);
            }, dur + 500);

            const gap = parseFloat(document.getElementById('gap-quiz-int').value) * 1000;
            nextRound(dur + 1500 + gap); 
        }
    }

    function logicChordQuiz(existingData = null) {
        let root, chordObj, notes, remainingRepeats, playStyle;
        
        if (existingData) {
            ({root, chordObj, notes, remainingRepeats, playStyle} = existingData);
        } else {
            root = getValidRoot();
            if(!root) { stop(); return; }

            const checkedChords = Array.from(document.querySelectorAll('#chord-list-quiz input:checked')).map(c=>c.value);
            if(checkedChords.length === 0) { alert("é€‰å’Œå¼¦"); stop(); return; }
            
            const typeId = checkedChords[Math.floor(Math.random()*checkedChords.length)];
            chordObj = getAllChords().find(c => c.id === typeId);
            
            notes = chordObj.int.map(i => root + i);
            if(document.getElementById('inv-quiz').checked && Math.random() > 0.5) {
                notes[0] += 12;
                notes.sort((a,b)=>a-b);
            }
            
            remainingRepeats = (parseInt(document.getElementById('repeat-quiz-chord').value) || 1) - 1;
            playStyle = (Math.random() > 0.5 ? 'arp' : 'harm');
        }

        const now = audioCtx.currentTime;
        let dur = 0;
        
        if(playStyle === 'arp') {
            notes.forEach((n,i) => playNote(n, now + i*0.2, 600));
            dur = notes.length * 200 + 400;
        } else {
            notes.forEach(n => playNote(n, now, 1200, 0.6/notes.length));
            dur = 1200;
        }

        updateStatus("ğŸ§ å¬è¾¨ä¸­...", `ç­‰å¾…è¯­éŸ³æ­æ™“... (å‰©ä½™é‡å¤: ${remainingRepeats})`);

        if (remainingRepeats > 0) {
            setTimeout(() => {
                if(!isPlaying) return;
                logicChordQuiz({root, chordObj, notes, remainingRepeats: remainingRepeats - 1, playStyle});
            }, dur + 600);
        } else {
            setTimeout(() => {
                if(!isPlaying) return;
                const speakRoot = document.getElementById('speak-root-chord').checked;
                const rootName = NOTE_NAMES[root % 12];
                let cName = chordObj.name.split(' ')[0];
                let text = speakRoot ? `${rootName} ${cName}` : cName;
                speak(text);
                updateStatus(`ç­”æ¡ˆ: ${text}`, `(${chordObj.name})`);
            }, dur + 500);

            const gap = parseFloat(document.getElementById('gap-quiz-chord').value) * 1000;
            nextRound(dur + 1500 + gap);
        }
    }

    function logicNoteQuiz(existingData = null) {
        let root, durMs, remainingRepeats;
        
        if (existingData) {
            ({root, durMs, remainingRepeats} = existingData);
        } else {
            root = getValidRoot();
            if(!root) { alert("è¯·åœ¨ä¸Šæ–¹é€šç”¨è®¾ç½®ä¸­é€‰æ‹©è‡³å°‘ä¸€ä¸ªéŸ³å"); stop(); return; }
            durMs = parseInt(document.getElementById('note-dur-quiz').value);
            remainingRepeats = (parseInt(document.getElementById('repeat-quiz-note').value) || 1) - 1;
        }

        const now = audioCtx.currentTime;
        playNote(root, now, durMs);
        updateStatus("ğŸ§ å¬è¾¨ä¸­...", `... (å‰©ä½™é‡å¤: ${remainingRepeats})`);

        if (remainingRepeats > 0) {
            setTimeout(() => {
                if(!isPlaying) return;
                logicNoteQuiz({root, durMs, remainingRepeats: remainingRepeats - 1});
            }, durMs + 600);
        } else {
            setTimeout(() => {
                if(!isPlaying) return;
                let name = NOTE_NAMES[root % 12];
                if(name.includes('#')) {
                    name = name.replace('#', '') + "å‡"; 
                }
                speak(name);
                updateStatus(`ç­”æ¡ˆ: ${name}`, `(Midi: ${root})`);
            }, durMs + 300);

            const gap = parseFloat(document.getElementById('gap-quiz-note').value) * 1000;
            nextRound(durMs + 1000 + gap);
        }
    }

</script>
</body>
</html>
